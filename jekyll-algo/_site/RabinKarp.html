<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rabin Karp</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous">

    <!--<link rel="stylesheet" href="style.css">-->

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2"
        crossorigin="anonymous"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300&display=swap');

        body {
            margin: auto;
            font-family: 'Poppins', sans-serif;
        }

        html {
            scroll-behavior: smooth;
        }

        .nav_bar {
            margin: auto;
            background-color: #6A889C;
            height: 3.5rem;
            position: fixed;
            width: 100%;
        }

        .nav_bar ul {
            list-style: none;
            display: flex;
            align-items: center;
            padding-top: 7px;
            margin-top: 0.5rem;
        }

        .nav_bar ul li {
            display: inline-block;
            margin: 0 auto;
        }

        .nav_bar ul li a {
            text-decoration: none;
            color: white;
        }

        .nav_bar ul li a:hover {
            color: black;
            font-weight: 600;
        }


        .content {
            padding-top: 3.5rem;
            margin: 0rem 1rem;
        }

        .code,
        .imple {
            padding-top: 5rem;
            margin-left: 1rem;

        }

        #gap2 {
            padding: 0rem 1.5rem 0rem 1.5rem;
        }

        #gap3 {
            padding-right: 4rem;
        }

        .buttons {
            color: white;
        }

        #container1,
        #container2,
        #container3 {
            font-size: 0.9rem;
            font-weight: 600;
        }

        #container3>h6 {
            font-weight: 600;
        }

        h6 {
            font-weight: 600;
        }

        .name {
            font-size: 20px;
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <nav class="nav_bar">
        <ul>
            <li><a button type="button" class="buttons" id="gap1" onclick="content()">Description</a></li>
            <li><a button type="button" class="buttons" id="gap2" onclick="imple()">Implementation</a></li>
            <li><a button type="button" class="buttons" id="gap3" onclick="code()">Code</a></li>
        </ul>
    </nav>
    <div id="content" class="content">
        
        <p class="name"><b>RABIN KARP</b></p>
        <div id="container1">
            <p>Rabin-Karp algorithm is an algorithm used for searching/matching patterns in the text using a hash function.  Unlike Naive string matching algorithm,  it does not travel through every character in the initial phase rather  it filters the characters that do not match and then performs the comparison.
</p>
        </div>

        <!--p>class="name"><b>ALGORITHM</b></p>
        <div id="container2">
            <p>Begin
  patLen := pattern Length
  strLen := string Length
  patHash := 0 and strHash := 0, h := 1
  maxChar := total number of characters in character set

  for index i of all character in pattern, do
    h := (h*maxChar) mod prime
  done

  for all character index i of pattern, do
    patHash := (maxChar*patHash + pattern[i]) mod prime
    strHash := (maxChar*strHash + text[i]) mod prime
  done

  for i := 0 to (strLen - patLen), do
    if patHash = strHash, then
      for charIndex := 0 to patLen -1, do
        if text[i+charIndex] ≠ pattern[charIndex], then
          break the loop
      done

      if charIndex = patLen, then
        print the location i as pattern found at i position.
      if i < (strLen - patLen), then
        strHash := (maxChar*(strHash – text[i]*h)+text[i+patLen]) mod prime, then
      if strHash < 0, then
        strHash := strHash + prime
  done
End
</p>
        </div-->

        <p class="name"><b>COMPLEXITY</b></p>
        <div id="container2">
            <p><h5>Time Complexity</h5>
The average and best-case running time of the Rabin-Karp algorithm is O(n+m), 
but its worst-case time is O(nm). <br><br>
Worst case of Rabin-Karp algorithm occurs when all characters of pattern and text are same as the hash 
values of all the substrings of txt[] match with hash value of pat[].
</p>
        </div>

        <p class="name"><b>WORKING</b></p>
        <div id="container3">
            <p>
Given a text txt[0..n-1] and a pattern pat[0..m-1], write a function search(char pat[], char txt[]) that prints all occurrences of pat[] in txt[].<br> 
You may assume that n > m.<br><br>
Rabin Karp algorithm matches the hash value of the pattern with the hash value of current substring of text, 
and if the hash values match then only it starts matching individual characters.<br><br>
So Rabin Karp algorithm needs to calculate hash values for following strings.<br>
  <li>1) Pattern itself. </li>
  <li>2) All the substrings of the text of length m. </li><br><br>
Since we need to efficiently calculate hash values for all the substrings of size m of text, we must have a hash function which has the following property. <br>
Hash at the next shift must be efficiently computable from the current hash value and next character in text or we can say 
hash(txt[s+1 .. s+m]) must be efficiently computable from hash(txt[s .. s+m-1]) and txt[s+m] i.e.,<br>
hash(txt[s+1 .. s+m])= rehash(txt[s+m], hash(txt[s .. s+m-1])) and rehash must be O(1) operation.<br><br>
The hash function suggested by Rabin and Karp calculates an integer value. <br>
The integer value for a string is the numeric value of a string.<br> <br>
For example, if all possible characters are from 1 to 10, the numeric value of “122” will be 122.<br> 
The number of possible characters is higher than 10 (256 in general) and pattern length can be large.<br>
So the numeric values cannot be practically stored as an integer.<br>
Therefore, the numeric value is calculated using modular arithmetic to make sure that the hash values can be stored in an integer variable (can fit in memory words). 
<br><br>
To do rehashing, we need to take off the most significant digit and add the new least significant digit for in hash value. <br>
Rehashing is done using the following formula.<br> <br>
hash( txt[s+1 .. s+m] ) = ( d ( hash( txt[s .. s+m-1]) – txt[s]*h ) + txt[s + m] ) mod q <br>
hash( txt[s .. s+m-1] ) = Hash value at shift s. <br>
hash( txt[s+1 .. s+m] ) = Hash value at next shift (or shift s+1) <br>
d = Number of characters in the alphabet <br>
q = A prime number <br>
h = d^(m-1)<br>
</p>
        </div>

    </div>

    <div id="code" class="code" style="display:none;">
        <pre><h6>
// Following program is a Javascript implementation
// of Rabin Karp Algorithm given in the CLRS book

// d is the number of characters in
// the input alphabet
let d = 256;

// A prime number
let q = 101;

/* pat -> pattern
  txt -> text
  q -> A prime number
*/
function search(pat, txt, q) {
  let M = pat.length;
  let N = txt.length;
  let i, j;

  // Hash value for pattern
  let p = 0;

  // Hash value for txt
  let t = 0;
  let h = 1;

  // The value of h would be "pow(d, M-1)%q"
  for (i = 0; i < M - 1; i++)
    h = (h * d) % q;

    // Calculate the hash value of pattern and
    // first window of text
    for (i = 0; i < M; i++) {
      p = (d * p + pat[i].charCodeAt()) % q;
      t = (d * t + txt[i].charCodeAt()) % q;
    }

    // Slide the pattern over text one by one
    for (i = 0; i <= N - M; i++) {

      // Check the hash values of current
      // window of text and pattern. If the
      // hash values match then only
      // check for characters one by one
      if (p == t) {

        /* Check for characters one by one */
        for (j = 0; j < M; j++) {
          if (txt[i + j] != pat[j])
            break;
        }

        // if p == t and pat[0...M-1] =
        // txt[i, i+1, ...i+M-1]
        if (j == M)
         "Pattern found at index " 
    
      }

      // Calculate hash value for next window
      // of text: Remove leading digit, add
      // trailing digit
      if (i < N - M) {
        t = (d * (t - txt[i].charCodeAt() * h) +
        txt[i + M].charCodeAt()) % q;

        // We might get negative value of t,
        // converting it to positive
        if (t < 0)
          t = (t + q);
      }
    }
  }
}









  







        </h6></pre>
    </div>
    </div>
    <div id="imple" class="imple" style="display:none">
        <div class="implementation">
 
  <div class="container">
    <div class="row">
      
      <div class="col-md-4">
        <h5>Enter text: </h5>
        <input type="text" class="form-control" id="input">
      </div>
      
      <div class="col-md-4">
        <h5>Enter text to be matched: </h5>
        <input type="text" class="form-control" id="input1">
      </div>
    </div><br>
    <h5>Click for answer:</h5>
    <button class="btn btn-primary" onclick="answer()">Submit</button><br><br>
    <h6>
      <div id="ans"></div>
    </h6>
  </div>
</div>
<script>

  // Following program is a Javascript implementation
  // of Rabin Karp Algorithm given in the CLRS book

  // d is the number of characters in
  // the input alphabet
  let d = 256;
  str = "";
  /* pat -> pattern
    txt -> text
    q -> A prime number
  */
  function search(pat, txt, q) {
    str += "Given text is:";
    str = str + "<br>" + txt + "<br>";
    str = str + "Given pattern to match is:" + "<br>";
    str += pat;
    str += "<br>";
    let M = pat.length;
    let N = txt.length;
    let i, j;

    // Hash value for pattern
    let p = 0;

    // Hash value for txt
    let t = 0;
    let h = 1;

    // The value of h would be "pow(d, M-1)%q"
    for (i = 0; i < M - 1; i++)
      h = (h * d) % q;

    // Calculate the hash value of pattern and
    // first window of text
    for (i = 0; i < M; i++) {
      p = (d * p + pat[i].charCodeAt()) % q;
      t = (d * t + txt[i].charCodeAt()) % q;
    }

    // Slide the pattern over text one by one
    for (i = 0; i <= N - M; i++) {

      // Check the hash values of current
      // window of text and pattern. If the
      // hash values match then only
      // check for characters one by one
      if (p == t) {

        /* Check for characters one by one */
        for (j = 0; j < M; j++) {
          if (txt[i + j] != pat[j])
            break;
        }

        // if p == t and pat[0...M-1] =
        // txt[i, i+1, ...i+M-1]
        if (j == M)
          str = str + "Pattern found at index " + i + "<br>";
        //document.getElementById("ans").innerHTML=str;
        //document.write("Pattern found at index " +
        //i + "<br/>");
      }

      // Calculate hash value for next window
      // of text: Remove leading digit, add
      // trailing digit
      if (i < N - M) {
        t = (d * (t - txt[i].charCodeAt() * h) +
          txt[i + M].charCodeAt()) % q;

        // We might get negative value of t,
        // converting it to positive
        if (t < 0)
          t = (t + q);
      }
    }
  }
  function answer() {
    // Driver code
    let txt = document.getElementById("input").value;
    let pat = document.getElementById("input1").value;

    // A prime number
    let q = 101;

    // Function Call
    search(pat, txt, q);
    document.getElementById("ans").innerHTML = str;

    // This code is contributed by target_2
  }


</script>

</body>

</html>
    </div>
    <script>
         function code() {
            var y = document.getElementsByClassName("code");
            y[0].style.display = "block";
            var z = document.getElementsByClassName("content");
            z[0].style.display = "none";
            var x = document.getElementsByClassName("imple");
            x[0].style.display = "none";
        }
        function imple() {
            var p = document.getElementsByClassName("imple");
            p[0].style.display = "block";
            var q = document.getElementsByClassName("content");
            q[0].style.display = "none";
            var r = document.getElementsByClassName("code");
            r[0].style.display = "none";
        }
        function content() {
            var a = document.getElementsByClassName("content");
            a[0].style.display = "block";
            var b = document.getElementsByClassName("imple");
            b[0].style.display = "none";
            var c = document.getElementsByClassName("code");
            c[0].style.display = "none";
        }
    </script>

</body>

</html>