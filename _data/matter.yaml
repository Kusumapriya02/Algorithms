
optimal: 
  head_name: OPTIMAL PAGE REPLACEMENT
  head_cont: >
    This algorithm replaces the page which will not be referred for so long in future. Although it
    can not be practically implementable but it can be used as a benchmark. Other algorithms are
    compared to this in terms of optimality. This decides which memory page is to be
    replaced. The process of replacement is sometimes called swap out or write to disk. It is
    done when the requested page is not found in the main memory.
  algo_cont: |
    1. Push the first page in the array as per the memory demand.<br>
    2. Push the second page as per the memory demand.<br>
    3. Push the third page until the memory is full.<br>
    4. As the array is full, the page which is least recently used is replaced.<br>
    5. repeat step '4' until the page demand continues and until the processing is over.<br>
    6. Terminate the program.
  working_cont: |
    Consider the page replacement string and number of frames as an example: pages = [ 7, 0, 1, 2,0, 3, 0, 4, 2, 3, 0, 3, 2] and 4 respectively.<br><br>
    <img src="https://i0.wp.com/technobyte.org/wp-content/uploads/2019/12/sym-1.jpg?ssl=1" style="width:100%;">
    <br><br>
    <li>Initially all the memory slots will be empty so [7, 0, 1, 2] will be allocated to the memory with 4 page-faults.</li><br>
    <li>As [0] is already there, there’s no page fault.</li><br>
    <li>Next in the string is [3] it’ll replace [7] as it’s not used for the longest period of time in the future, with one page fault.</li><br>
    <li>Again, 0 is already there, so no page fault.</li><br>
    <li>4 will replace 1 with one page fault.</li><br>
    <li>For the rest of the string, there will be no page fault as all the arriving pages are already there in the memory.</li>
  com_cont: |
    The Complexity of LRU Page Replacement Algorithm is O(n*m)<br>
    where'n' is number of pages and 'm' is number of frames.
  code_cont: |
    function optimalPage(pg, pn, fn) {
      var pfpercent, phpercent, fault;
      var fr = new Array(fn);
      var hit = 0, index = 0;
      for (var i = 0; i < pn; i++) {
        if (search(pg[i], fr)) {
            hit++;
            continue;
        }
        if (index < fn) {
            fr[index++] = pg[i];
        }else {
            var j = predict(pg, fr, pn, i + 1);
            fr[j] = pg[i];                            
        }
      }
    }
    function predict(pg, fr, pn, index) {
      let res = -1;
      var farthest = index;
      var index;
      for (var i = 0; i < fr.length; i++) {
        for (var j = index; j < pn; j++) {
          if (fr[i] == pg[j]) {
            if (j > farthest) {
              farthest = j;
              res = i;
            }
            break;
          }
        }
        if (j == pn) {
            return i;
        }
      }
      if (res == -1) {
        return o;
      } else {
        return res;
      }
    }
bubble: 
  head_name: BUBBLE SORT
  head_cont: >
    In this article, we will discuss the Bubble sort Algorithm.The working procedure of bubble sort is simplest.
    Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent
    elements if they are in the wrong order.This algorithm is not suitable for large data sets as its average and worst case time complexity is
    quite high.
  algo_cont: |
    begin BubbleSort(arr)  
      for all array elements  
        if arr[i] > arr[i+1]  
            swap(arr[i], arr[i+1])  
        end if  
      end for     
      return arr     
    end BubbleSort  
  working_cont: |
    Consider an array arr = {5, 1, 4, 2, 8}<br>  
    <h6>First Pass:</h6>  
    Bubble sort starts with very first two elements, comparing them to check which one is greater.<br><br>
    <li>( 5 1 4 2 8 ) –> ( 1 5 4 2 8 ), Here, algorithm compares the first two elements, and swaps since 5 > 1. </li>
    <li>( 1 5 4 2 8 ) –> ( 1 4 5 2 8 ), Swap since 5 > 4 </li>
    <li>( 1 4 5 2 8 ) –> ( 1 4 2 5 8 ), Swap since 5 > 2 </li>
    <li>( 1 4 2 5 8 ) –> ( 1 4 2 5 8 ), Now, since these elements are already in order (8 > 5), algorithm does not swap them.</li><br>
    <h6>Second Pass:</h6>
    Now, during second iteration it should look like this:<br><br>
    <li>( 1 4 2 5 8 ) –> ( 1 4 2 5 8 ) </li>
    <li>( 1 4 2 5 8 ) –> ( 1 2 4 5 8 ), Swap since 4 > 2</li>
    <li>( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )</li>
    <li>( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )</li><br>
    <h6>Third Pass:</h6>
    Now, the array is already sorted, but our algorithm does not know if it is completed.<br><br>
    The algorithm needs one whole pass without any swap to know it is sorted.<br>
    <li>( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )</li>
    <li>( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )</li>
    <li>( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )</li>
    <li>( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )</li>
  com_cont: |
    <h5>Time Complexity:</h5><br>
    The time Complexity of Bubble Sort Algorithm in all three cases is<br><br>
          &emsp;1. Best Case - O(N)<br>
          &emsp;2. Average Case - O(N^2)<br>
          &emsp;3. Worst Case - O(N^2)<br><br>
    <h5>Space Complexity:</h5><br>
    The space complexity of Selection Sort is O(1).<br>
    The Algorithm is Stable.
  code_cont: |
    function bubbleSort() {
    for (let k = 0; k < arr.length; k++) {
    //Inner pass
        for (let j = 0; j < arr.length - k - 1; j++) {
            //Value comparison using ascending order
            if (arr[j + 1] < arr[j]) {
            //Swapping
                [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];
            }
        }     
    }
selection:
  head_name : SELECTION SORT
  head_cont : >
    The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning.
    The algorithm maintains two subarrays in a given array.<br><br>
    <li>The subarray which is already sorted.</li>
    <li>Remaining subarray which is unsorted.</li><br>
    In every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray.
  algo_cont : |
    selectionSort(array, size)
      repeat (size - 1) times
        set the first unsorted element as the minimum
        for each of the unsorted elements
          if element < currentMinimum 
            set element as new minimum 
            swap minimum with first unsorted position 
    end selectionSort
  working_cont: |
    Consider the array as an example: arr[] = (5, 1, 4, 2, 8)<br><br>
    For each iteration the minimum element in the array will be swapped with the element present in
    first position in unsorted array. If the element is the minimum element then it remains unchanged.<br>
    <h6>First pass:</h6>
    After first pass, the element at first position i.e., '5' will be swapped with minimum valued element i.e., '1'.
    &emsp;(5, 1, 4, 2, 8) -> (1, 5, 4, 2, 8)<br>
    <h6>Second Pass:</h6>
    After second pass, the element at second position(or first position in unsorted array) i.e., '5'
    will be swapped with minimum valued element i.e., '2'.<br>
    &emsp;(1, 5, 4, 2, 8) -> (1, 2, 4, 5, 8)<br>
    Now the array is already sorted but the algorithm doesn't know whether it is sorted or not. So it continues...<br>
    <h6>Third Pass:</h6>
    After third pass, the element at third position(or first position in unsorted array) i.e., '4' will
    remain unchanged since it is the minimum element.<br>
    &emsp;(1, 2, 4, 5, 8) -> (1, 2, 4, 5, 8)<br>
    <h6>Fourth Pass:</h6>
    After fourth pass, the element at fourth position(or first position in unsorted array) i.e., '5'
    will remain unchanged since it is the minimum element.<br>
    &emsp;(1, 2, 4, 5, 8) -> (1, 2, 4, 5, 8)<br>
    <h6>Fifth Pass:</h6>
    After fifth pass, the element at fifth position(or first position in unsorted array) i.e., '8' will
    remain unchanged since it is the minimum element.<br>
    &emsp;(1, 2, 4, 5, 8) -> (1, 2, 4, 5, 8)<br>
  com_cont: |
    <h5>Time Complexity:</h5>
    The time Complexity of Selection Sort Algorithm in all three cases is<br><br>
      &emsp;1. Best Case - O(N^2)<br>
      &emsp;2. Average Case - O(N^2)<br>
      &emsp;3. Worst Case - O(N^2)<br><br>
    <h5>Space Complexity:</h5>
    The space complexity of Selection Sort is O(1).
  code_cont: |
    function selectionSort() {
      var i, j, min_idx;
      // One by one move boundary of unsorted subarray
      for (i = 0; i < arr.length - 1; i++) { 
        // Find the minimum element in unsorted array 
        min_idx=i; 
        for (j= i+1; j < arr.length; j++) { 
          if (arr[j] < arr[min_idx]) 
            min_idx=j; 
          } 
          // Swap the found minimum element with the first element 
          swap(arr, min_idx, i); 
        } 
      }
    }
insertion:
  head_name: INSERTION SORT
  head_cont: >
    The Insertion Sort is a simple algorithm with simple implementation. The array splits into sorted
    and unsorted part. The values from the unsorted part are picked placed at the correct position in the
    sorted part. It is appropriate for data sets which are already partially sorted.
  algo_cont: |
    begin InsertionSort(arr)
      for i in all array elements
        key <- arr[i]
        j <- i - 1
        while (j >= 0 && arr[j] > key) 
          arr[j + 1] <- arr[j]
          j = j - 1
          arr[j + 1] <- key
      end for
      return arr
    end InsertionSort
  working_cont: |
    Consider the array as an example: arr[] = (5, 1, 4, 2, 8)<br>
    <li>Compare the element with its adjacent element.</li>
    <li>For every comparison, we find a position in sorted array where the element can be
    inserted, then swap the corresponding elements and insert the element at the appropriate position.</li>
    <li>Repeat the above steps until one place the last element of unsorted array to its correct position.</li><br>
    <h6>First pass:</h6><br>
    Initially the first two elements will be compared in Insertion Sort.Here, 5 is greater than 1
    hence they are not in the ascending order and 5 is not at its correct position. Thus, swap 1 and 5.<br>
    So, for now the element is placed in sorted sub-array.<br>
    &emsp;(5, 1, 4, 2, 8) -> (1, 5, 4, 2, 8)<br><br>
    <h6>Second pass:</h6><br>
    Now the next two elements will be compared. The second element i.e.,5 is greater than third element
    i.e.,4. Thus, swap 5 and 4. <br>
    So, for now the element is placed in sorted sub-array.<br>
    &emsp;(1, 5, 4, 2, 8) -> (1, 4, 5, 2, 8)<br><br>
    <h6>Third pass:</h6><br>
    Now the next two elements will be compared. The third element i.e.,5 is greater than fourth element i.e.,2. Thus, swap 5 and 2. <br> 
    So, for now the element is placed in sorted sub-array.<br>
    &emsp;(1, 4, 5, 2, 8) -> (1, 4, 2, 5, 8)<br>
    But the elements 4 and 2 are not correctly placed since 4 is greater than 2. Thus, swap 4 and 2.<br>
    &emsp;(1, 4, 2, 5, 8) -> (1, 2, 4, 5, 8)<br>
    Now the array is already sorted but the algorithm doesn't know whether it is sorted or not. So it continues...<br><br>
    <h6>Fourth pass:</h6><br>
    Now the next two elements will be compared. The fourth element and fifth element are placed
    correctly.<br>
    Now the entire array is sorted.<br>
    &emsp;(1, 2, 4, 2, 8) -> (1, 2, 4, 5, 8)<br>
  com_cont: |
    <h5>Time Complexity:</h5>
    The time Complexity of Selection Sort Algorithm in all three cases is<br><br>
      &emsp;1. Best Case - O(N)<br>
      &emsp;2. Average Case - O(N^2)<br>
      &emsp;3. Worst Case - O(N^2)<br><br>
    <h5>Space Complexity:</h5>
    The space complexity of Selection Sort is O(1).
  code_cont: |
    function Insertionsort(int arr[])
    {
        int n = arr.length;
        for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int j = i - 1;
        /* Move elements of arr[0..i-1], that are
            greater than key, to one position ahead
            of their current position */
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
            }
            arr[j + 1] = key;
        }
    }
merge:
  head_name: MERGE SORT
  head_cont: >
    The Merge Sort algorithm is a sorting algorithm that is considered as an example of the divide and conquer strategy. 
    So, in this algorithm, the array is initially divided into two equal halves and then they are combined in a sorted manner.
    We can think of it as a recursive algorithm that continuously splits the array in half until it cannot be further divided.
    If the array has multiple elements, we split the array into halves and recursively invoke the merge sort on each of the halves. 
    Finally, when both the halves are sorted, the merge operation is applied.
    Merge operation is the process of taking two smaller sorted arrays and combining them to eventually make a larger one.
  algo_cont: |
    <li>Declare left variable to 0 and right variable to n-1.</li>
    <li>Find mid by medium formula. mid = (left+right)/2.</li>
    <li>Call merge sort on (left,mid).</li>
    <li>Call merge sort on (mid+1,rear).</li>
    <li>Continue till left is less than right.</li>
    <li>Then call merge function to perform merge sort.</li>
  working_cont: |
    To know the functioning of merge sort, lets consider an array arr = {38, 27, 43, 3, 9, 82, 10}.<br><br>
    At first, check if the left index of array is less than the right index, if yes then calculate its mid point.<br><br>
    <li> The array is {38,27,43,3,9,82,10}.Here l=left index and r=right index.</li>
    <li>Check if l < r, then m= l+(r-1)/2.</li>
    <li>Here l=0,r=7 and m=(0+6)/2=3.Here, we see that an array of 7 items is divided into two arrays of size 4 and 3 respectively
    i.e,{38,27,43,3} and {9,82,10}.</li><br>
    Now, again find that is left index is less than the right index for both arrays, if found yes, then again calculate mid points for both the arrays.<br><br>
    <li>Now,the arrays are divided into again two arrays i.e,{38,27} , {43,3} , {9,82} and {10}.</li><br>
    Now, further divide these two arrays into further halves, until the atomic units of the array is reached and further division is not possible.<br><br>
    <li>Now, the arrays are divided as {38},{27},{43},{3},{9},{82} and {10}.</li><br>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20220525094341/Artboard731-300x150.jpg"
    style="height:50%;"><br>
    After dividing the array into smallest units, start merging the elements again based on comparison of size of elements.<br><br>
    <li>Firstly, the arrays {38} and {27} get merged as {27,38}.</li>
    <li>Next, the arrays {43} and {3} get merged as {3,43}.</li>
    <li>Next, the arrays {9} and {82} get merged as it is {9,82}.</li>
    <li>The array {10} will be as it is as it is a single length array.</li><br>
    The further merging takes place as:<br><br>
    <li>Firstly, the arrays {27,38} and {3,43} get merged as {3,27,38,43}.</li>
    <li>Next, the arrays {9,82} and {10} get merged as {9,10,82}.</li><br>
    The further iteration of merging is as follows:<br><br>
    <li>Firstly, the arrays {3,27,38,43} and {9,10,82} get merged as {3,9,10,27,38,43,82}.</li>
    Hence, the final sorted array is {3,9,10,27,38,43,82}.<br><br>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20220525094459/Artboard751-300x150.jpg"><br>
    This is the working of merge sort algorithm.
  com_cont: |
    <h5>Time Complexity:</h5>
    The time Complexity of Merge Sort Algorithm in all three cases is same.<br><br>
      &emsp;1. Best Case - O(n logn)<br>
      &emsp;2. Average Case - O(n logn)<br>
      &emsp;3. Worst Case - O(n logn)<br><br>
    <h5>Space Complexity:</h5>
    The space complexity of Merge Sort is O(n).
    <li>In merge sort all elements are copied into an auxiliary array.</li> 
    <li>So N auxiliary space is required for merge sort.</li>
  code_cont: |
    function mergeSort(arr, l, r) {
        if (l >= r) {
            return;
        }
        var m = l + parseInt((r - l) / 2);
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }

    function merge(arr, l, m, r) {
        var n1 = m - l + 1;
        var n2 = r - m;

        var L = new Array(n1);
        var R = new Array(n2);

        for (var i = 0; i < n1; i++)
            L[i] = arr[l + i];
        for (var j = 0; j < n2; j++)
            R[j] = arr[m + 1 + j];

        var i = 0;
        var j = 0;
        var k = l;

        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            }
            else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
kmp:
  head_name: KMP Algorithm
  head_cont: >
    The KMP(Knuth Morris Pratt) algorithm is an efficient string matching algorithm due to Donald Knuth, Vaughan Pratt, and James H. Morris.
    It is a linear time algorithm that exploits the observation that every time a match (or a mismatch) happens, 
    the pattern itself contains enough information to dictate where the new examination should begin from.
    The KMP matching algorithm uses degenerating property (pattern having same sub-patterns appearing more than once in the pattern)
    of the pattern and improves the worst case complexity to O(n).
  algo_cont: |
    table[0] = 0
    i = 0, j = 1
    while (j < n) { // n is the length of pattern p
      if (p[i] == p[j]) {
        table[j] = i + 1;
        i++;
        j++;
      } else {
        if (i != 0) {
            i = table[i - 1];
            // Do not increment j here
        } else {
            table[j] = 0;
            j++;
        }
      }
    }
  working_cont: |
    Let us consider below example to understand KMP Algorithm.<br>
    Matching Overview
    txt = "AAAAABAAABA"<br> 
    pat = "AAAA"<br>
    We compare first window of txt with pat<br>
    txt = "AAAAABAAABA" <br>
    pat = "AAAA"  [Initial position] <br>
    We find a match.<br>
    In the next step, we compare next window of txt with pat.<br>
    txt = "AAAAABAAABA" <br>
    pat =  "AAAA" [Pattern shifted one position]<br>
    This is where KMP comes into picture. In this second window, we only compare fourth A of pattern
    with fourth character of current window of text to decide whether current window matches or not. Since we know 
    first three characters will anyway match, we skipped matching first three characters.<br><br>
    Here, how do we know how many characters to be skipped?<br>
    To know this, we pre-process pattern and prepare an integer array lps[ ] that tells us the count of characters to be skipped.<br>
    Preprocessing Overview:<br><br>
    KMP algorithm preprocesses pat[ ] and constructs an auxiliary lps[ ] of size m (same as size of pattern) which is used to skip characters while matching.<br>
    The name lps indicates longest proper prefix which is also suffix. A proper prefix is prefix with whole string not allowed.<br>
    We search for lps in sub-patterns. More clearly we focus on sub-strings of patterns that are either prefix and suffix.<br>
    For each sub-pattern pat[0..i] where i = 0 to m-1, lps[i] stores length of the maximum matching proper prefix which is also a suffix of the sub-pattern pat[0..i].<br><br>
    How to use lps?<br>
    We start comparison of pat[j] with j = 0 with characters of current window of text.<br>
    We keep matching characters txt[i] and pat[j] and keep incrementing i and j while pat[j] and txt[i] keep matching.<br>
    When we see a mismatch,
    We know that characters pat[0..j-1] match with txt[i-j…i-1] (Note that j starts with 0 and increment it only when there is a match).<br>
    We also know (from above definition) that lps[j-1] is count of characters of pat[0…j-1] that are both proper prefix and suffix.<br>
    From above two points, we can conclude that we do not need to match these lps[j-1] characters with txt[i-j…i-1] because we know that these characters will anyway match.<br> 
    Let us consider above example to understand this.<br><br>
    txt[] = "AAAAABAAABA" <br>
    pat[] = "AAAA"<br>
    lps[] = {0, 1, 2, 3}<br><br>
    i = 0, j = 0<br>
    txt[] = "AAAAABAAABA" <br>
    pat[] = "AAAA"<br>
    txt[i] and pat[j] match, do i++, j++<br><br>

    i = 1, j = 1<br>
    txt[] = "AAAAABAAABA" <br>
    pat[] = "AAAA"<br>
    txt[i] and pat[j] match, do i++, j++<br><br>

    i = 2, j = 2<br>
    txt[] = "AAAAABAAABA" <br>
    pat[] = "AAAA"<br>
    pat[i] and pat[j] match, do i++, j++<br><br>

    i = 3, j = 3<br>
    txt[] = "AAAAABAAABA" <br>
    pat[] = "AAAA"<br>
    txt[i] and pat[j] match, do i++, j++<br><br>

    i = 4, j = 4<br>
    Since j == M, print pattern found and reset j,<br>
    j = lps[j-1] = lps[3] = 3<br>

    Here unlike Naive algorithm, we do not match first three characters of this window. Value of lps[j-1] (in above step) gave us index of next character to match.<br>
    i = 4, j = 3<br>
    txt[] = "AAAAABAAABA" <br>
    pat[] =  "AAAA"<br>
    txt[i] and pat[j] match, do i++, j++<br><br>

    i = 5, j = 4<br>
    Since j == M, print pattern found and reset j,<br>
    j = lps[j-1] = lps[3] = 3<br><br>

    Again unlike Naive algorithm, we do not match first three characters of this window. Value of lps[j-1] (in above 
    step) gave us index of next character to match.<br>
    i = 5, j = 3<br>
    txt[] = "AAAAABAAABA" <br>
    pat[] =   "AAAA"<br>
    txt[i] and pat[j] do NOT match and j > 0, change only j<br>
    j = lps[j-1] = lps[2] = 2<br><br>

    i = 5, j = 2<br>
    txt[] = "AAAAABAAABA" <br>
    pat[] =    "AAAA"<br>
    txt[i] and pat[j] do NOT match and j > 0, change only j<br>
    j = lps[j-1] = lps[1] = 1 <br><br>

    i = 5, j = 1<br>
    txt[] = "AAAAABAAABA" <br>
    pat[] =     "AAAA"<br>
    txt[i] and pat[j] do NOT match and j > 0, change only j<br>
    j = lps[j-1] = lps[0] = 0<br><br>

    i = 5, j = 0<br>
    txt[] = "AAAAABAAABA" <br>
    pat[] =      "AAAA"<br>
    txt[i] and pat[j] do NOT match and j is 0, we do i++.<br><br>

    i = 6, j = 0<br>
    txt[] = "AAAAABAAABA" <br>
    pat[] =       "AAAA"<br>
    txt[i] and pat[j] match, do i++ and j++<br><br>

    i = 7, j = 1<br>
    txt[] = "AAAAABAAABA"<br> 
    pat[] =       "AAAA"<br>
    txt[i] and pat[j] match, do i++ and j++<br><br>
  com_cont: |
    <h5>Time Complexity:</h5>
    The time Complexity of KMP Algorithm is: O(n + m).
    <h5>Space Complexity:</h5>
    The space complexity of KMP Algorithm is:<br>
    <li>We only require as much space as the pattern. So, the space requirement is O(m).</li> 
  code_cont: |
    function makeTable(str) {
        var table = new Array(str.length);
        var maxPrefix = 0;
        table[0] = 0;
        for (var i = 1; i < str.length; i++) {
            while (maxPrefix > 0 && str.charAt(i) !== str.charAt(maxPrefix)) {
                maxPrefix = table[maxPrefix - 1];
            }
            if (str.charAt(maxPrefix) === str.charAt(i)) {
                maxPrefix++;
            }
            table[i] = maxPrefix;
        }
        return table;
    }
    function kmpMatching() {
        var str = document.getElementById("input").value;
        var word = document.getElementById("input1").value;
        var prefixes = makeTable(word);
        var matches = [];
        var j = 0;
        var i = 0;
        while (i < str.length) {
            if (str.charAt(i) === word.charAt(j)) {
                i++;
                j++;
            }
            if (j === word.length) {
                matches.push(i - j);
                j = prefixes[j - 1];
            }
            else if (str.charAt(i) !== word.charAt(j)) {
                if (j !== 0) {
                    j = prefixes[j - 1];
                } else {
                    i++;
                }
            }
        }
    }
firstfit:
  head_name: FIRST FIT 
  head_cont: >
    First Fit is a memory allocation scheme which fits data into memory by scanning from
    the beginning of available memory to the end, until the first free space which is at least big
    enough to accept the data is found. This space is then allocated to the data.
    It is fast in processing. As the processor allocates the nearest available memory partition to the
    data, it is very fast in execution.
  algo_cont: |
    1. Input memory blocks with size and processes with size.<br><br>
    2. Initialize all memory blocks as free.<br><br>
    3. Start by picking each process and check if it can be assigned to current block. <br><br>
    4. If size-of-process <= size-of-block if yes then assign and check for next process.<br><br>
    5. If not then keep checking the further blocks.
  working_cont: |
    
    Let us consider an example.<br>
    <br>Memory blocks available are : {100, 50, 30, 120, 35}<br>
    <br>Process sizes are : {20, 60, 70, 40}<br>
      <br><b>Process P1, size: 20</b><br>
      <br>
      <li>OS searches memory sequentially from starting.</li><br>
      <li>Block 1 fits, P1 gets assigned to Block 1.</li><br>
      <br><b>Process P2, size: 60</b><br>
      <br>
      <li>OS searches memory sequentially from Block 1 again.</li><br>
      <li>Block 1 is unavailable, Block 2 and 3 can’t fit.</li><br>
      <li>Block 4 fits, P2 assigned to Block 4.</li><br>
      <br><b>Process P3, size: 70</b><br>
      <br>
      <li>OS searches memory sequentially from Block 1 again</li><br>
      <li>Block 1 is unavailable, Block 2 and 3 can’t fit. Block 4 unavailable, Block 5 can’t fit.</li>
      <br>
      <li>P3 remains unallocated.</li><br>
      <br><b>Process P4, size: 40</b><br>
      <br>
      <li>OS searches memory sequentially from Block 1 again</li><br>
      <li>Block 1 is unavailable, Block 2 fits.</li><br>
      <li>P4 is assigned to Block 2.</li><br>
      
  com_cont: |
    
      The Complexity of First Fit Algorithm is O(nlogn),<br>
      where 'n' is number of processes.
    
  code_cont: |
    function firstFit(blockSize,m,processSize,n) {
 
      // Stores block id of the block allocated to a process
      const allocation = [];
                     
      // Initially no block is assigned to any process
      for (let i = 0; i < allocation.length; i++)
          allocation[i] = -1;
                     
      // pick each process and find suitable blocks according to its size and assign to it
      for (let i = 0; i < n; i++)
      {
          for (let j = 0; j < m; j++)
          {
              if (blockSize[j] >= processSize[i])
              {
                // allocate block j to p[i] process
                allocation[i] = j;
                     
                // Reduce available memory in this block.
                blockSize[j] -= processSize[i];
                     
                break;
              }
          }
        }
      }
quick:
  head_name: QUICK SORT
  head_cont: >
    Sorting is a way of arranging items in a systematic manner. 
    Quicksort is the widely used sorting algorithm that makes n log n comparisons in average case for sorting an array of n elements.
     It is a faster and highly efficient sorting algorithm.
     This algorithm follows the divide and conquer approach.
  algo_cont: |
    quickSort(arr[], low, high) {
      if (low < high) {
        pi = partition(arr, low, high);
        quickSort(arr, low, pi – 1);  
        quickSort(arr, pi + 1, high); 
      }
    }
    partition (arr[], low, high){
      pivot = arr[high];  
      i = (low – 1);
      for (j = low; j <= high- 1; j++){
        if (arr[j] < pivot){
          i++;   
          swap arr[i] and arr[j]
        }
      }
      swap arr[i + 1] and arr[high])
      return (i + 1)
    }
  working_cont: |
    Consider an arr = {10, 80, 30, 90, 40, 50, 70}.<br>
    Indexes:  0   1   2   3   4   5   6 <br>
    low = 0, high =  6, pivot = arr[h] = 70<br>
    Initialize index of smaller element, i = -1<br><br>
    Traverse elements from j = low to high-1.<br>
    <li>j = 0 : Since arr[j] <= pivot, do i++ and swap(arr[i], arr[j]).</li>
    <li>i = 0 .</li>
    arr[] = {10, 80, 30, 90, 40, 50, 70} // No change as i and j are same.<br><br>
    <li>j = 1: Since arr[j] > pivot, do nothing</li>
    <li>j = 2 : Since arr[j] <= pivot, do i++ and swap(arr[i], arr[j]).</li>
    <li>i = 1</li>
    arr[] = {10, 30, 80, 90, 40, 50, 70} // We swap 80 and 30 <br><br>
    <li>j = 3 : Since arr[j] > pivot, do nothing // No change in i and arr[].</li>
    <li>j = 4 : Since arr[j] <= pivot, do i++ and swap(arr[i], arr[j]).</li>
    <li>i = 2.</li>
    arr[] = {10, 30, 40, 90, 80, 50, 70} // 80 and 40 Swapped.<br><br>
    <li>j = 5 : Since arr[j] <= pivot, do i++ and swap arr[i] with arr[j].</li>
    <li>i = 3 </li>
    arr[] = {10, 30, 40, 50, 80, 90, 70} // 90 and 50 Swapped.<br><br>
    <li>We come out of loop because j is now equal to high-1.</li>
    <li>Finally we place pivot at correct position by swapping arr[i+1] and arr[high] (or pivot).</li>
    arr[] = {10, 30, 40, 50, 70, 90, 80} // 80 and 70 Swapped.<br><br>
    Now 70 is at its correct place. All elements smaller than 70 are before it and all elements greater than 70 are after it.<br><br>
    Since quick sort is a recursive function, we call the partition function again at left and right partitions.<br>
    Again call function at right part and swap 80 and 90.<br>
    <img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2014/01/QuickSort2.png" style="display:block; margin-left:auto; margin-right:auto; width:90%;">
  com_cont: |
    <h5>Time Complexity:</h5>
    The time Complexity of Quick Sort Algorithm is:<br><br>
      &emsp;1. Best Case - O(n logn)<br>
      &emsp;2. Average Case - O(n logn)<br>
      &emsp;3. Worst Case - O(n^2)<br><br></h5>
    <h5>Space Complexity:</h5>
    The Quick Sort is an in-place sorted algorithm.<br>
    <li>The default implementation of Quick Sort is not stable.</li> 
  code_cont: |
    /* The main function that implements QuickSort
          arr[] --> Array to be sorted,
          low --> Starting index,
          high --> Ending index
    */
    function quickSort(arr, low, high) {
        if (low < high) {
            // pi is partitioning index, arr[p]
            // is now at right place 
            
            let pi = partition(arr, low, high);

            // Separately sort elements before
            // partition and after partition
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }  
    /* This function takes last element as pivot, places
    the pivot element at its correct position in sorted
    array, and places all smaller (smaller than pivot)
    to left of pivot and all greater elements to right
    of pivot */
    function partition(arr, low, high) {
        // pivot
        let pivot = arr[high];
        // Index of smaller element and
        // indicates the right position
        // of pivot found so far
        let i = (low - 1);

        for (let j = low; j <= high - 1; j++) {
          // If current element is smaller 
          // than the pivot
            if (arr[j] < pivot) {
                // Increment index of 
                // smaller element
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return (i + 1);
    }
    // A utility function to swap two elements
    function swap(arr, i, j) {
        let temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
fifo:
  head_name: FIFO Page Replacement
  head_cont: >
    This is the simplest page replacement algorithm. 
    In this algorithm, operating system keeps track of all pages in the memory in a queue, oldest page is in the front of the queue.
     When a page needs to be replaced page in the front of the queue is selected for removal.
  algo_cont: |
    <li>1. Start traversing the pages.</li>
      &emsp<li>i) If set holds less pages than capacity.</li>
        a) Insert page into the set one by one until the size  of set reaches capacity or
         all page requests are processed.
        b) Simultaneously maintain the pages in the queue to perform FIFO.
        c) Increment page fault
      ii) Else 
        If current page is present in set, do nothing.
        Else 
          a) Remove the first page from the queue as it was the first to be entered in the memory.
          b) Replace the first page in the queue with the current page in the string.
          c) Store current page in the queue.
          d) Increment page faults.
    2. Return page faults.
  working_cont: |
    Consider the following reference string: 0, 2, 1, 6, 4, 0, 1, 0, 3, 1, 2, 1 and 4 page slots.<br><br>
    Initially all slots are empty, so when 0, 2, 1, 6 came they are allocated to the empty slots —> 4 Page Faults.<br>
    when 4 comes, it is not available in memory so it replaces the oldest page slot i.e,0,—> 1 Page Faults. <br>
    Then 0 comes, it is not available in memory so it replaces the oldest page slot i.e 2. —>1 Page Fault. <br>
    Now 1 comes, it is available in memory ->0 Page Fault.<br>
    Now 0 comes, it is available in memory ->0 Page Fault.<br>
    Now 3 comes, it is not available in memory so it replaces the oldest page slot i.e 1 —>1 Page Fault.<br>
    Next 1 comes, it is not available in memory so it replaces the oldest page slot i.e 6 —>1 Page Fault.<br>
    Now 2 comes, it is not available in memory so it replaces the oldest page slot i.e 4 —>1 Page Fault.<br>
    Now 1 comes, it is available in memory ->0 Page Fault.<br>
    So total page faults = 9.<br><br>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/PageReplacement.png" style="display:block; margin-left:auto; margin-right:auto; width:90%;"> 
  com_cont: |
    The Complexity of LRU Page Replacement Algorithm is O(n*m)<br>
    where'n' is number of pages and 'm' is number of frames.
  code_cont: |
    function fifo(pages, frames) {
      let pageFaults = 0;
      let temp = new Array(frames).fill(-1)
      var pageHits;
      var pfpercent;
      var phpercent;
      for (let i = 0; i < pages.length; i++) {
        let s = 0;
        for (let j = 0; j < frames; j++) {
          if (pages[i] === temp[j]) {
            s++;
            pageFaults--;
          }
        }
        pageFaults++;
        if ((pageFaults <= frames) && (s === 0)) {
          temp[i] = pages[i];
        } else if (s === 0) {
          let pageHitAndPageRatio = (pageFaults - 1) % frames
          temp[pageHitAndPageRatio] = pages[i];
        }
      }
subsetsum: 
  head_name: SUBSET SUM
  head_cont: >
    The Subset Sum Problem is all about displaying all subsets of the given array with a sum equal to a
    given sum. It is a variation of the 0-1 knapsack problem. In this, we have to
    pick items of some weight such that sum of weight of the picked items is equal to the capacity of
    the knapsack (x).
  algo_cont: |
    if sum == 0   
      return true  
    if sum < 0  
      return false  
    if (arr[] && sum!= 0)  
      return false  
    
  working_cont: |
    Now we consider the first element and now the required sum is equal to the difference between the target sum and value of first element.<br> 
    The number of elements is equal to the difference between the total elements and 1.<br>
    Leave the 'first' element and now the required sum = target sum. <br>
    The number of elements is equal to the difference between the total elements and 1. <br><br>
    Let's understand that how can we solve the problem using recursion. Consider the array which is given below:<bbr>
    arr = [3, 4, 5, 2] <br>
    sum = 9 <br>
    result = [] <br><br>
    In the above example, we have taken an array, and the empty array named result that stores all the values whose resultant sum is equal to 9.<br>
    First element in an array is 3. There are two scenarios:<br><br>
    <li>First scenario is select. The sum is equal to the target sum - value of first element, i.e., 9 - 3 = 6 and the first element, i.e., 3 gets stored in the result array, i.e., result[].</li>
    <li>Second scenario is reject. The array arr contains the elements 4, 5, 2, i.e., arr = [4, 5, 2] and sum would be same as 9 as we are rejecting the element 3. The result[] array would remain empty.</li><br>
    Now we perform the same select and reject operation on element 4 as it is the first element of the array now.
    <li>Select the element 4 from the array. Since we are selecting 4 from the array so array arr would contain the elements 5, 2, i.e., arr = [5, 2].
    The sum is equal to the 6-4 = 2 and the element 4 gets stored in the result arr. 
    The result[] = {3, 4}.</li><br>
    <li>Reject the element 4 from the array. 
    Since we are rejecting the 4 from the array so array arr would contain the elements 5, 2, i.e., arr = [5, 2]. 
    The sum would remain same as 6 and the result array would be same as previous, i.e., {3}.</li><br>
    Now we perform the select and reject operation on element 5.
    <li>Select the element 5 from the array. Since we are selecting 5 from the array so array arr would contain the elements 2, i.e., arr = [2].
    The sum is equal to the 2 - 5 equals to -3 and the element 5 gets stored in the result arr.
    The result[] = {3, 4, 5}.</li><br>
    <li>Reject the element 5 from the array. Since we are rejecting 5 from the array so array arr would contain the element 2, i.e., arr = [2].
    The sum would remain same as previous, i.e., 6 and the result array would be same as previous, i.e., {3, 4}.</li>
    If we observe S-5, we can see that the sum is negative that returns false. It means that there is no further subset available in the set.<br><br>
    Consider R-5. It also has two scenarios:<br><br>
    Select the element 2 from the array. Once the element 2 gets selected, the array becomes empty, i.e., arr[] = " ". The sum would be 2-2 equals to 0 and the element 2 gets stored in the result array. The result[] = [3, 4, 2].<br>
    Reject the element 2 from the array. Once the element 2 gets rejected, the array becomes empty, i.e., arr[] = " ". The sum would be same as previous, i.e., 2 and the result array would also be same as previous, i.e., [3, 4].<br><br>
    Consider R-4. It has two scenarios:<br><br>
    Select the element 5 from the array. Since we are selecting 5 from the array so array arr would contain the elements 2, i.e., arr = [2]. The sum would be 6-5 equals to 1 and the element 5 gets stored in the result array. The result[] = [3, 5].<br>
    Reject the element 5 from the array. Since we are rejecting 5 from the array so array arr would contain the element 2, i.e., arr = [2]. The sum would remain same as previous, i.e., 6 and the result array would be same as previous, i.e., {3}.<br><br>
    Consider S-5. It has two scenarios:<br><br>
    Select the element 2 from the array. Since we are selecting 2 from the array so array arr would be empty, i.e., arr = " ". The sum would be 1-2 equals to -1 and the element 2 gets stored in the result array. The result[] = [3, 5, 2].<br>
    Reject the element 2 from the array. Since we are rejecting 2 from the array so array arr would become empty. The sum would remain same as previous, i.e., 1 and the result array would be same as previous, i.e., {3, 5}.<br><br>
    Consider R-5. It has two scenarios:<br><br>
    Select the element 2 from the array. Since we are selecting 2 from the array so array arr would be empty, i.e., arr = " ". The sum would be 6-2 equals to 4 and the element 2 gets stored in the result array. The result[] = [3, 2].<br>
    Reject the element 2 from the array. Since we are rejecting 2 from the array so array arr would become empty. The sum would remain same as previous, i.e., 6 and the result array would be same as previous, i.e., {3}.<br><br>
    <img src="https://static.javatpoint.com/tutorial/daa/images/subset-sum-problem8.png" style="display:block; margin-left:auto; margin-right:auto; width:90%;">
  com_cont: |
    The above solution may try all subsets of given set in worst case. <br>
    Therefore time complexity of the above solution is exponential.
  code_cont: |
    function printSubsetsRec(arr, i, sum, p) {
        if (i === 0 && sum !== 0 && dp[0][sum] !== 0) {
            p.push(arr[i]);
            p = [];
            return;
        }
        if (i == 0 && sum == 0) {
            p = [];
            return;
        }
        if (dp[i - 1][sum]) {
            b = [...p];
            printSubsetsRec(arr, i - 1, sum, b);
        }
        if (sum >= arr[i] && dp[i - 1][sum - arr[i]]) {
            p.push(arr[i]);
            printSubsetsRec(arr, i - 1, sum - arr[i], p);
        }
        return;
    }
    function printAllSubsets(arr, n, sum) {
      if (n == 0 || sum < 0)
        return;
      for (let i = 0; i < n; i++) {
        dp[i] = [];
        for (let j = 0; j < sum + 1; j++)
          dp[i].push(false);
        }
        for (let i = 0; i < n; i++)
            dp[i][0] = true;
        if (arr[0] <= sum)
            dp[0][arr[0]] = true;
        for (var i = 1; i < n; i++) {
            for (let j = 0; j < sum + 1; j++) {
                if (arr[i] <= j)
                    dp[i][j] = (dp[i - 1][j] || dp[i - 1][j - arr[i]]);
                else
                    dp[i][j] = dp[i - 1][j];
            }
        }
        if (dp[n - 1][sum] == false) {
            return;
        }
        p = [];
        printSubsetsRec(arr, n - 1, sum, p);
    }
Nqueen:
  head_name: N-Queens Problem
  head_cont: >
    This problem is to find an arrangement of N queens on a chess board, such that no queen can attack any other queens on the board.
    The chess queens can attack in any direction as horizontal, vertical, horizontal and diagonal way.
    A binary matrix is used to display the positions of N Queens, where no queens can attack other queens.
  algo_cont: |
    isValid()
      Begin
        if there is a queen at the left of current col, then
          return false
        if there is a queen at the left upper diagonal, then
          return false
        if there is a queen at the left lower diagonal, then
          return false;
        return true //otherwise it is valid place
      End
    solveNQUtil(board, col)
      Begin
        if all columns are filled, then
          return true
        for each row of the board, do
          if isValid(board, i, col), then
            set queen at place (i, col) in the board
            if solveNQueen(board, col+1) = true, then
              return true
            otherwise remove queen from place (i, col) from board.
        done
        return false
      End
  working_cont: |
    It can be seen that for n =1, the problem has a trivial solution, and no solution exists for n =2 and n =3.<br> 
    So first we will consider the 4 queens problem and then generate it to n - queens problem.<br>
    Given a 4 x 4 chessboard and number the rows and column of the chessboard 1 through 4.<br>
    <img src="https://static.javatpoint.com/tutorial/daa/images/n-queens-problems.png" 
    style="width:25%; display:block; margin:1rem auto;">
    Since, we have to place 4 queens such as q1 q2 q3 and q4 on the chessboard, such that no two queens attack each other.<br>
    In such a conditional each queen must be placed on a different row, i.e., we put queen "i" on row "i."<br>
    Now, we place queen q1 in the very first acceptable position (1, 1). <br><br>
    Next, we put queen q2 so that both these queens do not attack each other.<br>
    We find that if we place q2 in column 1 and 2, then the dead end is encountered. <br><br>
    Thus the first acceptable position for q2 in column 3, i.e. (2, 3) but then no position is left for placing queen 'q3' safely.<br> 
    So we backtrack one step and place the queen 'q2' in (2, 4), the next best possible solution. <br>
    Then we obtain the position for placing 'q3' which is (3, 2). <br><br>
    But later this position also leads to a dead end, and no place is found where 'q4' can be placed safely. <br>
    Then we have to backtrack till 'q1' and place it to (1, 2) and then all other queens are placed safely by moving q2 to (2, 4), q3 to (3, 1) and q4 to (4, 3).<br><br>
    That is, we get the solution (2, 4, 1, 3). This is one possible solution for the 4-queens problem. <br>
    For another possible solution, the whole method is repeated for all partial solutions.<br> 
    The other solutions for 4 - queens problems is (3, 1, 4, 2) i.e.<br>
    <img src="https://static.javatpoint.com/tutorial/daa/images/n-queens-problems2.png"
    style="width:25%; display:block; margin:1rem auto;">
    The implicit tree for 4 - queen problem for a solution (2, 4, 1, 3) is as follows:<br>
    <img src="https://static.javatpoint.com/tutorial/daa/images/n-queens-problems3.png"
    style="width:35%; display:block; margin:0 auto;"><br>
    It can be seen that all the solutions to the 4 queens problem can be represented as 4 - tuples (x1, x2, x3, x4) where xi represents the column on which queen "qi" is placed.<br>
    In this way it can be done to all the another numbers.
  com_cont: |
    <h5>Time Complexity:</h5>
    The time Complexity of N-Queen problem is: O(N!) <br><br>
    <h5>Space Complexity:</h5>
    The space complexity of N-Queens problem is: O(N)
  code_cont: |
    function solveNQ(N) {
        if (N <= 3) {
            "Solution doesn't exist"
        }
        var board = new Array(N);
        for (var i = 0; i < N; i++) {
            board[i] = new Array(N);
            for (var j = 0; j < N; j++) {
                board[i][j] = 0;
            }
        }
        if (solveNQUtil(board, 0) == false) {
            return false;
        }
        return true;
    }
    function solveNQUtil(board, col) {
        if (col >= N)
            return true;
        for (let i = 0; i < N; i++) {
            if ((ld[i - col + N - 1] != 1 &&
                rd[i + col] != 1) && cl[i] != 1) {
                board[i][col] = 1;
                ld[i - col + N - 1] =
                    rd[i + col] = cl[i] = 1;
                if (solveNQUtil(board, col + 1))
                    return true;
                board[i][col] = 0;
                ld[i - col + N - 1] =
                    rd[i + col] = cl[i] = 0;
            }
        }
        return false;
    };
worstfit:
  head_name: WORST FIT 
  head_cont: >
    Worst Fit allocates a process to the memory block which is largest sufficient among the freely
    available blocks available in the main memory. If a large process comes at a later stage, then
    memory will not have space to accommodate it.<br>
    Since this process chooses the largest memory block, therefore there will be large internal
    fragmentation. Now, this internal fragmentation will be quite big so that other small processes can
    also be placed in that leftover block. <br>
    It is a slow process because it traverses all the blocks in the memory and then selects the largest
    block among all the memory blocks, which is a time-consuming process.
  algo_cont: |
    1. Input memory blocks with size and processes with sizes.<br><br>
    2. Initialize all memory blocks as free.<br><br>
    3. Start by picking each process and find the maximum block size that can be assigned 
    to current process i.e.,<br> 
    find max(bockSize[1],blockSize[2],.....blockSize[n]) > processSize[current],<br> 
    if found then assign it to the current process. <br><br>
    4. If not then leave that process and keep checking
    the further processes.
  working_cont: |
    Let us consider an example.<br>
    <br>Memory blocks available are : {100, 500, 200, 300, 600}<br>
    <br>Process sizes are : {212, 417, 112, 426}<br>
    <br><b>Process P1, size: 212</b><br>
    <br>
    <li>Block 1, Block 3 cannot fit.</li><br>
    <li>For Block 2, the memory wastage is 500-212 = 288</li><br>
    <li>For Block 4, the memory wastage is 300-212 = 88</li><br>
    <li>For Block 5, the memory wastage is 600-212 = 388</li><br>
    <li>P1 (212) is allocated to Block 5. 388 size is left in Block 5.</li><br>
    <br><b>Process P2, size: 417</b><br>
    <br>
    <li>Block 1, Block 3, Block 4, Block 5 cannot fit.</li><br>
    <li>P2 (417) is allocated to Block 2. 83 size is left in Block 2.</li><br>
    <br><b>Process P3, size: 112</b><br>
    <br>
    <li>Block 1, Block 2 cannot fit.</li><br>
    <li>For Block 3, the memory wastage is 200-112 = 88 </li><br>
    <li>For Block 4, the memory wastage is 300-112 = 188</li><br>
    <li>For Block 5, the memory wastage is 388-112 = 276</li><br>
    <li>P3 (112) is allocated to Block 5. 276 size is left in Block 5.</li><br>
    <br><b>Process P4, size: 426</b><br>
    <br>
    <li>P4 (426) can't be allocated to any blocks. It remains unallocated</li>
  com_cont: |
    
      The time complexity of Worst Fit algorithm is O(n),<br>
      where n is the number of processes.
    
  code_cont: |
    // Method to allocate memory to blocks as per worst fit algorithm
    function worstFit(blockSize, m, processSize, n)
    {
      // Stores block id of the block allocated to a process
      let allocation = new Array(n);
           
      // Initially no block is assigned to any process
      for(let i = 0; i < allocation.length; i++)
        allocation[i] = -1;
           
      // Pick each process and find suitable blocks according to its size ad assign to it
      for(let i = 0; i < n; i++)
      { 
        // Find the best fit block for current process
        let wstIdx = -1;
        for(let j = 0; j < m; j++)
        {
          if (blockSize[j] >= processSize[i])
          {
            if (wstIdx == -1)
              wstIdx = j;
            else if (blockSize[wstIdx] < blockSize[j])
              wstIdx = j;
          }
        }
           
        // If we could find a block for current process
        if (wstIdx != -1)
        {    
          // Allocate block j to p[i] process
          allocation[i] = wstIdx;
           
          // Reduce available memory in this block.
          blockSize[wstIdx] -= processSize[i];
        }
    }
bestfit: 
  head_name: BEST FIT
  head_cont: |
    Best Fit is a memory management algorithm; it deals with allocating smallest free partition which
    meets the requirement of the requesting process.<br>
    The operating system searches the memory blocks, when the operating system finds the memory block
    with minimum wastage of memory, it is allocated to the process.<br>
    In Best fit memory allocation scheme, the operating system searches that can –<br>
    <li>Accommodate the process</li>
    <li>Also, leaves the minimum memory wastage</li><br>
    This method is memory efficient. The operating system allocates the job minimum possible space in
    the memory, making memory management very efficient. To save memory from getting wasted, it is the
    best method.
  algo_cont: |
    1. Input memory blocks with size and processes with sizes.<br><br>
    2. Initialize all memory blocks as free.<br><br>
    3. Start by picking each process and find the minimum block size that can be assigned to
    current process i.e.,<br> 
    find min(bockSize[1],blockSize[2],.....blockSize[n]) > processSize[current],<br> 
    if found then assign it to the current process. <br><br>
    4. If not then leave that process and keep checking
    the further processes.
  working_cont: |
    Let us consider an example.<br>
    <br>Memory blocks available are : {150, 350}<br>
    <br>Process sizes are : {300, 25, 125, 50}<br>
    <br><b>Process P1, size: 300</b><br>
    <br>
    <li>Block 1 cannot fit.</li><br>
    <li>P1 (300) is allocated to Block 2 of size 350. 50 size is left in Block 2.</li><br>
    <br><b>Process P2, size: 25</b><br>
    <br>
    <li>P2 (25) is allocated to the remaining 50 size of Block 2. 25 size is left in Block 2.</li><br>
    <br><b>Process P3, size: 125</b><br>
    <br>
    <li>P3 (125) is allocated to Block 1 (150). 25 size is left in Block 1. </li><br>
    <br><b>Process P4, size: 50</b><br>
    <br>
    <li>P4 (50) can't be allocated even if there is 25+25 size available.</li><br>
  com_cont: |
    
      The time complexity of Best Fit algorithm is O(n),<br>
      where n is the number of processes.
    
  code_cont: |
    // Function to allocate memory to blocks as per Best fit algorithm
    function bestFit(int blockSize[], int m, int processSize[], int n)
    {
      // Stores block id of the block allocated to a process
      const allocation = [];

      // Initially no block is assigned to any process
      for (let i = 0; i < allocation.length; i++)
        allocation[i] = -1;

      // pick each process and find suitable blocks according to its size ad assign to it
      for (let i=0; i < n; i++)
      {
        //Find the best fit block for current process
        let bestIdx = -1;
        for (int j=0; j < m; j++)
        {
          if (blockSize[j] >= processSize[i])
          {
            if (bestIdx == -1)
              bestIdx = j;
            else if (blockSize[bestIdx] > blockSize[j])
              bestIdx = j;
          }
        }

        // If we could find a block for current process
        if (bestIdx != -1)
        {
            // allocate block j to p[i] process
            allocation[i] = bestIdx;

            // Reduce available memory in this block.
            blockSize[bestIdx] -= processSize[i];
        }
      }
    }
hamil: 
  head_name: HAMILTONIAN CYCLE
  head_cont: >
    Hamiltonian cycle also known as Hamiltonian circuit, is a path such that each vertex is visited
    exactly once and there is also an edge in graph from the last vertex to the first vertex of the
    Path. The path in which each vertex is visited only once is known as Hamiltonian Path.
  algo_cont: |
    path=[]; visited=[];
    path[] <- source vertex
    Now add vertices recursively to path one by one to path
    But before adding Check if vertex can be added to Cycle
    if isSafe
      path[] <- v
      visited[v] <- true
    else
      visited[v] <- false
    If there is an edge from last vertex to source vertex then print path.
  working_cont: |
    Consider the below image which can be described as<br><br>
    <img src="https://res.cloudinary.com/codecrucks/image/upload/c_scale,w_134,h_130,dpr_1.5/f_webp,q_auto/v1635003549/hamilonian-cycle-02.png?_i=AA"
    style="display:block; margin-left:auto; margin-right:auto; width:21%;">
    <pre>
      graph = [<br>
        [0, 1, 1, 1],<br>
        [1, 0, 1, 1],<br>
        [1, 1, 0, 0],<br>
        [1, 1, 0, 0]<br>
      ];</pre><br><br>
    We can start with any random vertex. Let us start with vertex A.<br><br>
    <img src="https://res.cloudinary.com/codecrucks/image/upload/c_scale,w_38,h_38,dpr_1.5/f_webp,q_auto/v1635003548/hamilonian-cycle-03-1.png?_i=AA"
    class="img-fluid" style="margin-left:auto; margin-right:auto; display:block; padding:10px;">
    <br>Neighbors of A are {B, C, D}. So let's start with inclusion of B. But the inclusion of B doesn't to complete solution as shown below.
    <br>
    <img src="https://res.cloudinary.com/codecrucks/image/upload/c_scale,w_88,h_95,dpr_1.5/f_webp,q_auto/v1635003547/hamilonian-cycle-04.png?_i=AA"
    class="img-fluid" style="float: left; width: 30%; display:flex; flex-direction:row; justify-content:space-around; margin-left:2%; padding: 10px; height:180px; box-sizing:border-box;">
    <img src="https://res.cloudinary.com/codecrucks/image/upload/c_scale,w_142,h_153,dpr_1.5/f_webp,q_auto/v1635003543/hamilonian-cycle-05.png?_i=AA"
    class="img-fluid" style="float: left; width: 30%; display:flex; flex-direction:row; justify-content:space-around; margin-left:2%; padding: 10px; height:180px; box-sizing:border-box;">
    <img src="https://res.cloudinary.com/codecrucks/image/upload/c_scale,w_147,h_153,dpr_1.5/f_webp,q_auto/v1635003541/hamilonian-cycle-06.png?_i=AA"
    class="img-fluid" style="float: left; width: 30%; display:flex; flex-direction:row; justify-content:space-around; margin-left:2%; padding: 10px; height:180px; box-sizing:border-box;">
    <br><br><br><br><br><br><br><br><br>
    So now we need to backtrack and go to B. Now B does not have any more neighbors, so we need to
    backtrack and go to A. Now we need to explore the next neighbor of A i.e. C. By repeating the same
    procedure, the path
    A - C - B - D - A is detected as the Hamiltonian cycle of the input graph.<br><br>
    <img src="https://res.cloudinary.com/codecrucks/image/upload/c_scale,w_100,h_108,dpr_1.5/f_webp,q_auto/v1635003650/hamilonian-cycle-07.png?_i=AA"
    class="img-fluid" style="float: left; width: 30%; display:flex; flex-direction:row; padding-top:15px; justify-content:space-around;  margin-left:2%; padding: 10px; height:180px; box-sizing:border-box;">
    <img src="https://res.cloudinary.com/codecrucks/image/upload/c_scale,w_150,h_161,dpr_1.5/f_webp,q_auto/v1635003654/hamilonian-cycle-08.png?_i=AA"
    class="img-fluid" style="float: left; width: 30%; display:flex; flex-direction:row; padding-top:15px; justify-content:space-around;  margin-left:2%; padding: 10px; height:180px; box-sizing:border-box;">
    <img src="https://res.cloudinary.com/codecrucks/image/upload/c_scale,w_150,h_165,dpr_1.5/f_webp,q_auto/v1635003657/hamilonian-cycle-09.png?_i=AA"
    class="img-fluid" style="float: left; width: 30%; display:flex; flex-direction:row; padding-top:15px; justify-content:space-around;  margin-left:2%; padding: 10px; height:180px; box-sizing:border-box;">
    <br><br><br><br><br><br><br><br><br>
    Similarly, if we choose vertex D, then also hamilonian cycle is detected. The path will be A - D - B - C - A.
    <br>This is how the hamiltonian cycle works.
    <br>
  com_cont: |
    <h5>Time Complexity:</h5>
    The time Complexity of Hamiltonian Cycle is O(N!).<br><br>
    
    <h5>Space Complexity:</h5>
    The space complexity of Selection Sort is O(N).
  code_cont: |
    function isSafe(v, graph, path, pos)
    {
      // If the vertex is adjacent to
      // the vertex of the previously
      // added vertex
      if (graph[path[pos - 1]][v] == 0)
        return false;
                    
      // If the vertex has already
      // been included in the path
      for (let i = 0; i < pos; i++)
        if (path[i] == v)
            return false;
                    
        // Both the above conditions are
        // not true, return true
        return true;
    }
                    
    // To check if there existsat least 1 hamiltonian cycle
                    
    // Function to find all possible
    // hamiltonian cycles
    function hamCycle(graph)
    {
      // Initially value of boolean
      // flag is false
      hasCycle = false;
      // Store the resultant path
      let path = [];
      path.push(0);
      // Keeps the track of the
      // visited vertices
      let visited = new Array(graph.length);
      for (let i = 0; i < visited.length; i++)
        visited[i] = false;
      visited[0] = true;
      // Function call to find all
      // hamiltonian cycles
      FindHamCycle(graph, 1, path, visited);
      if (!hasCycle) {
        // If no Hamiltonian Cycle
        // is possible for the
        // given graph
        return;
      }
    }
                    
    // Recursive function to find all
    // hamiltonian cycles
    function FindHamCycle(graph, pos, path, visited)
    {
      // If all vertices are included
      // in Hamiltonian Cycle
      if (pos == graph.length) {
        // If there is an edge
        // from the last vertex to
        // the source vertex
        if (graph[path[path.length - 1]][path[0]] != 0) {
          // Include source vertex
          // into the path and
          // print the path
          path.push(0);
          for (let i = 0; i < path.length; i++) {
            document.write(path[i] + " ");
          }
          // Remove the source
          // vertex added
          path.pop();
          // Update the hasCycle
          // as true
          hasCycle = true;
        }
        return;
      }
                    
      // Try different vertices
      // as the next vertex
      for (let v = 0; v < graph.length; v++) {
        // Check if this vertex can
        // be added to Cycle
        if (isSafe(v, graph, path, pos) && !visited[v]) {    
            path.push(v);
            visited[v] = true;
             // Recur to construct
            // rest of the path
            FindHamCycle(graph, pos + 1, path, visited);
            // Remove current vertex
            // from path and process
            // other vertices
            visited[v] = false;
            path.pop();
        }
      }
    }
lrupage: 
  head_name: LRU PAGE REPLACEMENT
  head_cont: >
    Least Recently Used (LRU) algorithm is a page replacement technique used for memory management. In this
    algorithm, the page that is least recently used in the current set will be replaced. That
    is, in the left side of the table that we created we choose the further most page to get replaced.
  algo_cont: |
    <h5>
      Let capacity be the number of pages that memory can hold. Let set be the current set of pages in memory.<br><br>
      1.Start traversing the pages.<br>
      &emsp;i. If set holds less pages than capacity.<br>
      <ul>
        a) Insert page into the set one by one until the size of set reaches capacity or all
        page requests are processed.<br>
        b) Simultaneously maintain the recent occurred index of each page in a map called indexes.<br>
        c) Increment page fault</ul>
        &emsp;ii. Else <br>
        <ul>
          <ul>
            If <br>&emsp;current page is present in set, do nothing.
          </ul>
          &emsp;&nbsp;Else <br>
          <ul>
            &emsp;a) Find the page in the set that was least recently used. We find it using index array.
            We basically need to replace the page with minimum index.<br>
            &emsp;b) Replace the found page with current page.<br>
            &emsp;c) Increment page faults.<br>
            &emsp;d) Update index of current page.<br>
          </ul>
        </ul>
        2. Return page faults.
    </h5>
  working_cont: |
    
      Consider the reference string and number of frames as pages = [ 7, 0, 1, 2,
      0, 3, 0, 4, 2, 3, 0, 3, 2] and 4 respectively.<br><br>
      <img src="https://i0.wp.com/technobyte.org/wp-content/uploads/2019/12/sym-1.jpg?ssl=1" style="display:block; margin-left:auto; margin-right:auto; width:90%;">
      <br><br>
      <li>Initially all the memory slots will be empty so [7, 0, 1, 2] will be allocated to the memory
          with 4 page-faults.</li><br>
      <li>As [0] is already available in the page frames, it hits. Page fault remains the same.</li><br>
      <li>Next in the string is [3]. Since [7] is the least recently used, so [3] replaces [7]. It results in
          1 page fault.</li><br>
      <li>Since, [0] is already present, the page hits and page faults remains same.</li><br>
      <li>Next in the string is [4]. Since [1] is the least recently used, so [4] replaces [1]. It results in
          1 page fault.</li><br>
      <li>Since the rest of the string is already present in the frames, so there will be no page fault as all
          the arriving pages are already there in the memory.</li><br>
    
  com_cont: |
    
      The Complexity of LRU Page Replacement Algorithm is O(n*m)
      <br> where'n' is number of pages and 'm' is number of frames.
    
  code_cont: |
    
    function pageFaults(pages,n,frame_number)
    {
      n = pages.length;
      // To represent set of current pages. We use
      // an unordered_set 'left' so that we quickly check
      // if a page is present in set or not
      let left = new Set();
      // To store least recently used indexes
      // of pages.
      let indexes = new Map();
      // Start from initial page
      let page_faults = 0;
      for (let i=0; i< n; i++)
      {
        // Check if the set can hold more pages
        if (left.size < frame_number)
        {
          // Insert it into set if not present
          //already which represents page fault
          if (!left.has(pages[i]))
          {
            left.add(pages[i]);       
            // increment page fault
            page_faults++;
          }
    
          // Store the recently used index of
          // each page
          indexes.set(pages[i], i);
        }
                        
        // If the set is full then need to perform lru
        // i.e. remove the least recently used page
        // and insert the current page
        else
        {
          // Check if current page is not already
          // present in the set
          if (!left.has(pages[i]))
          {
            // Find the least recently used pages
            // that is present in the set
            let lru = Number.MAX_VALUE, val=Number.MIN_VALUE;
            for(let itr of left.values()) {
              let temp = itr;
              if (indexes.get(temp) < lru)
              {
                lru = indexes.get(temp);
                val = temp;
              }
            }               
            // Remove the indexes page
            left.delete(val);
            //remove lru from hashmap
            indexes.delete(val);
            // insert the current page
            left.add(pages[i]);
            // Increment page faults
            page_faults++;
          }
          // Update the current page index
          indexes.set(pages[i], i);
        }
      }                
      return page_faults;
    }
toh: 
  head_name: TOWER OF HANOI 
  head_cont: >
    
      The Tower of Hanoi, is a mathematical problem which consists of three rods and multiple disks.
      Initially, all the disks are placed on one rod, one over the other in ascending order of their size.
      The objective of this problem is to move the stack of disks from the initial rod to another rod,
      following these rules:
      <li>A disk cannot be placed on top of a smaller disk.</li>
      <li>No disk can be placed on top of the smaller disk.</li>
      The goal is to move all the disks from the leftmost rod to the rightmost rod.
    
  algo_cont: |
    <h5>
      Our main goal is to move disk n from source to destination and then put all other (n-1) disks onto it.
      We apply the same in a recursive way for the given number of disks.
      <li>Move n-1 disks from source to aux</li>
      <li>Move nth disk from source to dest</li>
      <li>Move n-1 disks from aux to dest</li>
    </h5>
  working_cont: |
    
      Consider the number of disks as 3 as shown in the image below in which the smallest and uppermost disk
      is green disk. Now we need to shift all the disks from rod1 to rod3.
      <img src="https://miro.medium.com/max/1238/1*qA35jDn_DupDo444YETkKA.jpeg"
        style="width:30%; display:block; margin-left:auto; margin-right:auto; padding:10px;">
      <li>The smallest green disk , the uppermost disk on the stack is shifted from rod 1 to rod 3.</li>
      <img src="https://miro.medium.com/max/1230/1*x2tuSfFifbU2SlSsk3riZQ.jpeg"
        style="width:30%; display:block; margin-left:auto; margin-right:auto; padding:10px;">
      <li>Next the uppermost disk on rod 1 is the blue colored disk which is shifted to rod 2.</li>
      <img src="https://miro.medium.com/max/1230/1*kbPUu50Nvkq2ay_k_cR8WQ.jpeg"
        style="width:30%; display:block; margin-left:auto; margin-right:auto; padding:10px;">
      <li>The smallest disk placed on rod 3 is shifted back on to the top of rod 2.</li>
      <img src="https://miro.medium.com/max/1236/1*ao5Fpwc7RVZIYe9W6xYoiA.jpeg"
        style="width:30%; display:block; margin-left:auto; margin-right:auto; padding:10px;">
      <li>So now the largest red disk is allowed to be shifted from rod 1 to its destination rod 3.</li>
      <img src="https://miro.medium.com/max/1256/1*oRvhwq1He4EZm5iVFk0oHg.jpeg"
        style="width:30%; display:block; margin-left:auto; margin-right:auto; padding:10px;">
      <li>Now the two disks on rod 2 has to be shifted to its destination rod 3 on top of the red disk , so
        first the smallest green disk on top of the blue rod is shifted to rod 1 .</li>
      <img src="https://miro.medium.com/max/1224/1*GR74bVaOH4t62LISBmmXJg.jpeg"
        style="width:30%; display:block; margin-left:auto; margin-right:auto; padding:10px;">
      <li> Next the blue disk is permitted to be shifted to its destination rod 3 that will stacked on to the
        top of the red disk.</li>
      <img src="https://miro.medium.com/max/1316/1*LKoGbylYT9qWv75oBy1pbg.jpeg"
        style="width:30%; display:block; margin-left:auto; margin-right:auto; padding:10px;">
      <li>Finally , the smallest green colored rod is also shifted to rod 3 , which would now be the uppermost
        rod on the stack.</li>
      <img src="https://miro.medium.com/max/1304/1*4hpSLRcmpM9j7p72G-lkeA.jpeg"
        style="width:30%; display:block; margin-left:auto; margin-right:auto; padding:10px;">
      Now all the disks are shifted from source rod to the destination rod.
    
  code_cont: |
    function towerOfHanoi(number_of_disks, source_rod, destination_rod, via_rod) {
      if (number_of_disks == 0) {
        return;
      }
      towerOfHanoi(number_of_disks - 1, source_rod, via_rod, destination_rod);
      towerOfHanoi(number_of_disks - 1, via_rod, destination_rod, source_rod);
    }
rabinkarp: 
  head_name: RABIN KARP
  head_cont: >
    Rabin-Karp algorithm is an algorithm used for searching/matching patterns in the text using a hash function. 
    Unlike Naive string matching algorithm, 
    it does not travel through every character in the initial phase rather 
    it filters the characters that do not match and then performs the comparison.
  algo_cont: |
    Begin
      patLen := pattern Length
      strLen := string Length
      patHash := 0 and strHash := 0, h := 1
      maxChar := total number of characters in character set

      for index i of all character in pattern, do
        h := (h*maxChar) mod prime
      done

      for all character index i of pattern, do
        patHash := (maxChar*patHash + pattern[i]) mod prime
        strHash := (maxChar*strHash + text[i]) mod prime
      done

      for i := 0 to (strLen - patLen), do
        if patHash = strHash, then
          for charIndex := 0 to patLen -1, do
            if text[i+charIndex] ≠ pattern[charIndex], then
              break the loop
          done

          if charIndex = patLen, then
            print the location i as pattern found at i position.
          if i < (strLen - patLen), then
            strHash := (maxChar*(strHash – text[i]*h)+text[i+patLen]) mod prime, then
          if strHash < 0, then
            strHash := strHash + prime
      done
    End
  working_cont: |

    Given a text txt[0..n-1] and a pattern pat[0..m-1], write a function search(char pat[], char txt[]) that prints all occurrences of pat[] in txt[].<br> 
    You may assume that n > m.<br><br>
    Rabin Karp algorithm matches the hash value of the pattern with the hash value of current substring of text, 
    and if the hash values match then only it starts matching individual characters.<br><br>
    So Rabin Karp algorithm needs to calculate hash values for following strings.<br>
      <li>1) Pattern itself. </li>
      <li>2) All the substrings of the text of length m. </li><br><br>
    Since we need to efficiently calculate hash values for all the substrings of size m of text, we must have a hash function which has the following property. <br>
    Hash at the next shift must be efficiently computable from the current hash value and next character in text or we can say 
    hash(txt[s+1 .. s+m]) must be efficiently computable from hash(txt[s .. s+m-1]) and txt[s+m] i.e.,<br>
    hash(txt[s+1 .. s+m])= rehash(txt[s+m], hash(txt[s .. s+m-1])) and rehash must be O(1) operation.<br><br>
    The hash function suggested by Rabin and Karp calculates an integer value. <br>
    The integer value for a string is the numeric value of a string.<br> <br>
    For example, if all possible characters are from 1 to 10, the numeric value of “122” will be 122.<br> 
    The number of possible characters is higher than 10 (256 in general) and pattern length can be large.<br>
    So the numeric values cannot be practically stored as an integer.<br>
    Therefore, the numeric value is calculated using modular arithmetic to make sure that the hash values can be stored in an integer variable (can fit in memory words). 
    <br><br>
    To do rehashing, we need to take off the most significant digit and add the new least significant digit for in hash value. <br>
    Rehashing is done using the following formula.<br> <br>
    hash( txt[s+1 .. s+m] ) = ( d ( hash( txt[s .. s+m-1]) – txt[s]*h ) + txt[s + m] ) mod q <br>
    hash( txt[s .. s+m-1] ) = Hash value at shift s. <br>
    hash( txt[s+1 .. s+m] ) = Hash value at next shift (or shift s+1) <br>
    d = Number of characters in the alphabet <br>
    q = A prime number <br>
    h = d^(m-1)<br>
  com_cont: |
    <h5>Time Complexity</h5>
    The average and best-case running time of the Rabin-Karp algorithm is O(n+m), 
    but its worst-case time is O(nm). <br><br>
    Worst case of Rabin-Karp algorithm occurs when all characters of pattern and text are same as the hash 
    values of all the substrings of txt[] match with hash value of pat[].
  code_cont: |
  
    // Following program is a Javascript implementation
    // of Rabin Karp Algorithm given in the CLRS book

    // d is the number of characters in
    // the input alphabet
    let d = 256;

    // A prime number
    let q = 101;
  
    /* pat -> pattern
      txt -> text
      q -> A prime number
    */
    function search(pat, txt, q) {
      let M = pat.length;
      let N = txt.length;
      let i, j;

      // Hash value for pattern
      let p = 0;

      // Hash value for txt
      let t = 0;
      let h = 1;

      // The value of h would be "pow(d, M-1)%q"
      for (i = 0; i < M - 1; i++)
        h = (h * d) % q;

        // Calculate the hash value of pattern and
        // first window of text
        for (i = 0; i < M; i++) {
          p = (d * p + pat[i].charCodeAt()) % q;
          t = (d * t + txt[i].charCodeAt()) % q;
        }

        // Slide the pattern over text one by one
        for (i = 0; i <= N - M; i++) {

          // Check the hash values of current
          // window of text and pattern. If the
          // hash values match then only
          // check for characters one by one
          if (p == t) {

            /* Check for characters one by one */
            for (j = 0; j < M; j++) {
              if (txt[i + j] != pat[j])
                break;
            }

            // if p == t and pat[0...M-1] =
            // txt[i, i+1, ...i+M-1]
            if (j == M)
             "Pattern found at index " 
        
          }

          // Calculate hash value for next window
          // of text: Remove leading digit, add
          // trailing digit
          if (i < N - M) {
            t = (d * (t - txt[i].charCodeAt() * h) +
            txt[i + M].charCodeAt()) % q;

            // We might get negative value of t,
            // converting it to positive
            if (t < 0)
              t = (t + q);
          }
        }
      }
    }
srtf:
  
  head_name: SHORTEST REMAINING TIME FIRST SCHEDULING ALGORITHM
  head_cont: >
    The process with the smallest amount of time remaining until completion is selected to execute.
    Since the currently executing process is the one with the shortest amount of time remaining by definition, 
    and since that time should only reduce as execution progresses, 
    processes will always run until they complete or a new process is added that requires a smaller amount of time.
  working_cont: |
    Consider the following table of arrival time and burst time for five processes P1, P2, P3, P4 and P5. <br>
    Process=[P1,P2,P3,P4,P5]<br>
    Arrival Time=[2,5,1,0,4]<br>
    Burst Time=[6,2,8,3,4]<br>
    The Shortest Job First CPU Scheduling Algorithm will work on the basis of steps as mentioned below:<br>
    At time = 0, Process P4 arrives and starts executing.<br>
    At time= 1, <br><&nbsp;>Process P3 arrives.<br><&nbsp;>But, as P4 has a shorter burst time. It will continue execution.<br><&nbsp;>Thus, P3 will wait till P4 gets executed.<br>
    At time =2,<br><&nbsp;>Process P1 arrives with burst time = 6.<br><&nbsp;>As the burst time of P1 is more than that of P4.<br><&nbsp;>Thus, P4 will continue its execution.<br>
    At time = 3,<br><&nbsp;>Process P4 will finish its execution.<br><&nbsp;>Then, the burst time of P3 and P1 is compared.<br><&nbsp;>Process P1 is executed because its burst time is less as compared to P3.<br>
    At time = 4,<br><&nbsp;>Process P5 arrives.<br><&nbsp;>Then the burst time of P3, P5, and P1 is compared.<br><&nbsp;>Process P5 gets executed first among them because its burst time is lowest, and process P1 is preempted.<br>
    At time = 5, <br><&nbsp;>Process P2 arrives.<br><&nbsp;>The burst time of all processes are compared, <br><&nbsp;>Process P2 gets executed as its burst time is lowest among all. <br><&nbsp;>Process P5 is preempted.<br>
    At time = 6,<br><&nbsp;>Process P2 will keep executing.<br><&nbsp;>It will execute till time = 8 as the burst time of P2 is 2ms.<br>
    At time=7, <br><&nbsp;>The process P2 finishes its execution.<br><&nbsp;>Then again the burst time of all remaining processes is compared.<br><&nbsp;>The Process P5 gets executed because its burst time is lesser than the others.<br>
    At time = 10,<br><&nbsp;>The process P5 will finish its execution.<br><&nbsp;>Then the burst time of the remaining processes P1 and P3 is compared.<br><&nbsp;> Thus, process P1 is executed as its burst time is less than P3.<br>
    At time = 15,<br><&nbsp;>The process P1 finishes its execution and P3 is the only process left.<br><&nbsp;>P3 will start executing.<br>
    At time = 23, Process P3 will finish its execution.<br>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20220427173554/UntitledDiagram3-660x69.jpg" style="display:block; margin-left:auto; margin-right:auto; width:90%;">
    <br>
    Turn Around Time :<br> 
    P1 : 15-2 = 13<br>
    P2 : 7-5 = 2<br>
    P3 : 23-1 = 22<br>
    P4 : 3-0 = 3<br>
    P5 : 10-4 = 6<br>
    Waiting Time :<br> 
    P1 : 13-6 = 7<br>
    P2 : 2-2 = 0<br>
    P3 : 22-8 = 14<br>
    P4 : 3-3 = 0<br>
    P5 : 6-4 = 2<br>
    Average Turn around time = (13 + 2 + 22 + 3 + 6)/5 = 9.2<br>
    Average waiting time = (7 + 0 + 14 + 0 + 2)/5 = 23/5 = 4.6<br>
  com_cont: |
    Time Complexity: O(N)
  code_cont: |
    function findWaitingTime(art, bt, n, wt) {
        let rt = new Array(n);

        for (let i = 0; i < n; i++)
            rt[i] = bt[i];

        let complete = 0, t = 0, minm = Number.MAX_VALUE;
        let shortest = 0, finish_time;
        let check = false;

        while (complete != n) {
            for (let j = 0; j < n; j++) {
               if ((art[j] <= t) &&
                    (rt[j] < minm) && rt[j] > 0) {
                        minm = rt[j];
                        shortest = j;
                        check = true;
                    }
                }

            if (check == false) {
                t++;
                continue;
            }
            rt[shortest]--;
            minm = rt[shortest];
            if (minm == 0)
                minm = Number.MAX_VALUE;

            if (rt[shortest] == 0) {

                complete++;
                check = false;
                
                finish_time = t + 1;
                
                wt[shortest] = finish_time -
                        bt[shortest] -
                        art[shortest];
                if (wt[shortest] < 0)
                    wt[shortest] = 0;
                }
                t++;
            }
        }

        function findTurnAroundTime(art, bt, n, wt, tat) {
            for (let i = 0; i < n; i++)
                tat[i] = bt[i] + wt[i];
        }

        function findavgTime(art, bt, n) {
            let wt = new Array(n), tat = new Array(n);
            let total_wt = 0, total_tat = 0;

            findWaitingTime(art, bt, n, wt);

            findTurnAroundTime(art, bt, n, wt, tat);

            var proc = new Array(n);
            for (var i = 0; i < n; i++) {
                proc[i] = new Array(4);
                total_wt = total_wt + wt[i];
                total_tat = total_tat + tat[i];
                proc[i][0] = i + 1;
                proc[i][1] = bt[i];
                proc[i][2] = wt[i];
                proc[i][3] = tat[i];
            }
         }

  

  



  
            
